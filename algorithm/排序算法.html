<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>最常见的八大排序算法 | Jorson的个人博客</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="欢迎来到Jorson的个人博客">
    
    <link rel="preload" href="/kw-blog/assets/css/0.styles.41f8f72f.css" as="style"><link rel="preload" href="/kw-blog/assets/js/app.b958d4e2.js" as="script"><link rel="preload" href="/kw-blog/assets/js/2.1e882bb7.js" as="script"><link rel="preload" href="/kw-blog/assets/js/3.f163c3d7.js" as="script"><link rel="prefetch" href="/kw-blog/assets/js/10.16ab3e3f.js"><link rel="prefetch" href="/kw-blog/assets/js/11.c2fa39b1.js"><link rel="prefetch" href="/kw-blog/assets/js/12.a6ee2b4e.js"><link rel="prefetch" href="/kw-blog/assets/js/13.7801f0b4.js"><link rel="prefetch" href="/kw-blog/assets/js/14.4f9f6969.js"><link rel="prefetch" href="/kw-blog/assets/js/15.34c109c7.js"><link rel="prefetch" href="/kw-blog/assets/js/16.336c82c3.js"><link rel="prefetch" href="/kw-blog/assets/js/17.c461c0c5.js"><link rel="prefetch" href="/kw-blog/assets/js/18.672355b5.js"><link rel="prefetch" href="/kw-blog/assets/js/19.9b09ceb8.js"><link rel="prefetch" href="/kw-blog/assets/js/20.a5d0a3a0.js"><link rel="prefetch" href="/kw-blog/assets/js/21.89bf4e4e.js"><link rel="prefetch" href="/kw-blog/assets/js/22.8d895b93.js"><link rel="prefetch" href="/kw-blog/assets/js/23.c2b20fca.js"><link rel="prefetch" href="/kw-blog/assets/js/4.78725ba6.js"><link rel="prefetch" href="/kw-blog/assets/js/5.3664bea7.js"><link rel="prefetch" href="/kw-blog/assets/js/6.5ec75146.js"><link rel="prefetch" href="/kw-blog/assets/js/7.c57989ef.js"><link rel="prefetch" href="/kw-blog/assets/js/8.67b977fe.js"><link rel="prefetch" href="/kw-blog/assets/js/9.2faab3a0.js">
    <link rel="stylesheet" href="/kw-blog/assets/css/0.styles.41f8f72f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/kw-blog/" class="home-link router-link-active"><!----> <span class="site-name">Jorson的个人博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/kw-blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://github.com/Jorson007" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://juejin.cn/user/2163471667175549" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/kw-blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://github.com/Jorson007" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://juejin.cn/user/2163471667175549" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端学习</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>iOS学习</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>swift</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Flutter学习</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>算法学习</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/kw-blog/algorithm/排序算法.html" class="active sidebar-link">排序算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/kw-blog/algorithm/排序算法.html#最常见的八大排序算法" class="sidebar-link">最常见的八大排序算法</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>图像相关</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>杂七杂八</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="最常见的八大排序算法"><a href="#最常见的八大排序算法" class="header-anchor">#</a> 最常见的八大排序算法</h2> <p>说到数据结构和算法，最基础的便是八大排序和三大查找了，所谓排序，无非是按照一定规则将一组数据从无序变成有序。
本篇文章主要是介绍八大排序算法，首先对这八种排序算法分类如下：</p> <p><img src="/kw-blog/assets/img/1.d72e2827.png" alt="排序算法分类"></p> <p>接下来是对以上八种排序的性能比较：</p> <p><img src="/kw-blog/assets/img/2.ca63e7e7.png" alt="排序算法性能比较"></p> <p>从表中我们可以看到一项指标：<strong>稳定性</strong>。所谓稳定性，是指在待排序的序列中有多个相同项，在排序前和排序后它们的相对位置有没有发生变化。</p> <p>举个栗子：
幼儿园有十个小朋友，现在要将他们按身高进行排序，小明和小刚身高一样高，排序前小明站在小刚前面，如果排完序后小明还在小刚前面，那么排序就是稳定的，反之亦然。</p> <p>一个用来记排序稳定性的小诀窍<br>
“快些选堆”: 其中“快”指快速排序，“些”指希尔排序，“选”指选择排序，“堆”指堆排序，即这四种排序方法是不稳定的，其他自然都是稳定的。</p> <p>接下来对这八种排序方式逐一讲解，示例中均按升序排列进行讲解，并附上代码（Javascript版）。</p> <h3 id="冒泡排序"><a href="#冒泡排序" class="header-anchor">#</a> 冒泡排序</h3> <blockquote><p>算法思想：
通过一系列的“交换”动作完成，首先第一个元素与第二个元素比较，如果第一个大，则二者交换，否则不交换；然后第二个元素和第三个元素比较，如果第二个大，则二者交换，否则不交换，以此类推，最终最大的那个元素被交换到了最后，一趟冒泡排序完成。在这个过程中，大的元素就像一块石头一样沉底，小的元素逐渐向上浮动。冒泡排序算法结束的条件是一趟排序没有发生元素交换。</p></blockquote> <p><img src="/kw-blog/assets/img/1.33a947c7.gif" alt="冒泡排序"></p> <p>代码：</p> <div class="language- extra-class"><pre class="language-text"><code>function bubbleSort(arr) {
    var len = arr.length;
    for (var i = 0; i &lt; len - 1; i++) {
        for (var j = 0; j &lt; len - 1 - i; j++) {
            if (arr[j] &gt; arr[j+1]) {        
                var temp = arr[j+1];        
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}

</code></pre></div><h3 id="选择排序"><a href="#选择排序" class="header-anchor">#</a> 选择排序</h3> <blockquote><p>算法思想：
初始时在序列中找到最小的元素，放到序列的起始位置作为已排序序列。然后再从剩余未排序元素中继续寻找最小元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p></blockquote> <p><img src="/kw-blog/assets/img/2.1c7e20f3.gif" alt="选择排序"></p> <p>代码：</p> <div class="language- extra-class"><pre class="language-text"><code>function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i &lt; len - 1; i++) {
        minIndex = i;
        for (var j = i + 1; j &lt; len; j++) {
            if (arr[j] &lt; arr[minIndex]) {     // 寻找最小的数
                minIndex = j;                 // 将最小数的索引保存
            }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    return arr;
} 

</code></pre></div><h3 id="直接插入排序"><a href="#直接插入排序" class="header-anchor">#</a> 直接插入排序</h3> <blockquote><p>算法思想：
通过一系列的“插入”动作完成，首先第一个元素作为已排序序列，取出第二个元素，在已排序序列中从后往前扫描，如果该元素比第二个元素大，则将该元素往后移一位，然后再选中第三个元素重复上面的扫描操作，直到所有元素有序。</p></blockquote> <p><img src="/kw-blog/assets/img/3.91b76e8e.gif" alt="插入排序"></p> <p>代码：</p> <div class="language- extra-class"><pre class="language-text"><code>function insertionSort(arr) {
    var len = arr.length;
    var preIndex, current;
    for (var i = 1; i &lt; len; i++) {
        preIndex = i - 1;
        current = arr[i];
        while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) {
            arr[preIndex + 1] = arr[preIndex];
            preIndex--;
        }
        arr[preIndex + 1] = current;
    }
    return arr;
}

</code></pre></div><h3 id="希尔排序"><a href="#希尔排序" class="header-anchor">#</a> 希尔排序</h3> <blockquote><p>算法思想：
希尔排序实际上是直接插入排序的改进版，将待排序序列按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。</p></blockquote> <p><img src="/kw-blog/assets/img/4.671bd19a.gif" alt="希尔排序"></p> <p>代码：</p> <div class="language- extra-class"><pre class="language-text"><code>function shellSort(arr) {
    var len = arr.length;
    for (var gap = Math.floor(len / 2); gap &gt; 0; gap = Math.floor(gap / 2)) {
        // 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行
        for (var i = gap; i &lt; len; i++) {
            var j = i;
            var current = arr[i];
            while (j - gap &gt;= 0 &amp;&amp; current &lt; arr[j - gap]) {
                 arr[j] = arr[j - gap];
                 j = j - gap;
            }
            arr[j] = current;
        }
    }
    return arr;
}

</code></pre></div><h3 id="归并排序"><a href="#归并排序" class="header-anchor">#</a> 归并排序</h3> <blockquote><p>算法思想：
归并排序是采用分治法的一种排序方式，将局部有序慢慢扩展到全部有序。先将无序序列对半分成两组，分别对这两组进行归并排序（逐层拆分，直到拆无可拆），然后再将这两个有序的数组合并成一个有序的数组。</p></blockquote> <p><img src="/kw-blog/assets/img/5.cdda3f11.gif" alt="归并排序"></p> <p>代码：</p> <div class="language- extra-class"><pre class="language-text"><code>function mergeSort(arr) {
    var len = arr.length;
    if (len &lt; 2) {
        return arr;
    }
    var middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
}
 
function merge(left, right) {
    var result = [];
 
    while (left.length&gt;0 &amp;&amp; right.length&gt;0) {
        if (left[0] &lt;= right[0]) {
            result.push(left.shift());
        } else {
            result.push(right.shift());
        }
    }
 
    while (left.length)
        result.push(left.shift());
 
    while (right.length)
        result.push(right.shift());
 
    return result;
}

</code></pre></div><h3 id="快速排序"><a href="#快速排序" class="header-anchor">#</a> 快速排序</h3> <blockquote><p>算法思想：
快速排序也是采用分治法的另一种排序方式，先从无序序列中选出一个元素作为基准，然后将序列中所有比基准数（pivot）小的元素放在基准数前面，将所有比基准数（pivot）大的元素放在基准数后面；然后递归的将基准数前的无序序列进行同样的操作（基准数后面的无序序列也要），直到最终该序列有序。</p></blockquote> <p><img src="/kw-blog/assets/img/6.c411339b.gif" alt="快速排序"></p> <p>代码：</p> <div class="language- extra-class"><pre class="language-text"><code>function quickSort(arr, left, right) {
    var len = arr.length,
        partitionIndex,
        left = typeof left != 'number' ? 0 : left,
        right = typeof right != 'number' ? len - 1 : right;
 
    if (left &lt; right) {
        partitionIndex = partition(arr, left, right);
        quickSort(arr, left, partitionIndex-1);
        quickSort(arr, partitionIndex+1, right);
    }
    return arr;
}
 
function partition(arr, left ,right) {     // 分区操作
    var pivot = left,                      // 设定基准值（pivot）
        index = pivot + 1;
    for (var i = index; i &lt;= right; i++) {
        if (arr[i] &lt; arr[pivot]) {
            swap(arr, i, index);
            index++;
        }       
    }
    swap(arr, pivot, index - 1);
    return index-1;
} 
 
function swap(arr, i, j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

</code></pre></div><h3 id="堆排序"><a href="#堆排序" class="header-anchor">#</a> 堆排序</h3> <p>堆的定义：
1.堆的每一个父节点都大于（或小于）其子节点；
2.堆的每个左子树或者右子树也是一个堆；</p> <blockquote><p>算法思想：
堆排序实际上是利用堆这种数据结构设计的一种排序算法，堆是一种近似完全二叉树的数据结构；堆排序实际上是建立大顶堆（或小顶堆）的过程；</p></blockquote> <ol><li>将初始待排序关键字序列(R1,R2....Rn)构建成大顶堆，此堆为初始的无序区；</li> <li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,......Rn-1)和新的有序区(Rn),且满足R[1,2...n-1]&lt;=R[n];</li> <li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,......Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2....Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ol> <p><img src="/kw-blog/assets/img/7.7073c729.gif" alt="堆排序"></p> <p>代码：</p> <div class="language- extra-class"><pre class="language-text"><code>var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量
 
function buildMaxHeap(arr) {   // 建立大顶堆
    len = arr.length;
    for (var i = Math.floor(len/2); i &gt;= 0; i--) {
        heapify(arr, i);
    }
}
 
function heapify(arr, i) {     // 堆调整
    var left = 2 * i + 1,
        right = 2 * i + 2,
        largest = i;
 
    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) {
        largest = left;
    }
 
    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) {
        largest = right;
    }
 
    if (largest != i) {
        swap(arr, i, largest);
        heapify(arr, largest);
    }
}
 
function swap(arr, i, j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
 
function heapSort(arr) {
    buildMaxHeap(arr);
 
    for (var i = arr.length - 1; i &gt; 0; i--) {
        swap(arr, 0, i);
        len--;
        heapify(arr, 0);
    }
    return arr;
}
</code></pre></div><h3 id="基数排序"><a href="#基数排序" class="header-anchor">#</a> 基数排序</h3> <blockquote><p>算法思想
基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p></blockquote> <p><img src="/kw-blog/assets/img/8.3a6f1e50.gif" alt="基数排序"></p> <div class="language- extra-class"><pre class="language-text"><code>var counter = [];
function radixSort(arr, maxDigit) {
    var mod = 10;
    var dev = 1;
    for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) {
        for(var j = 0; j &lt; arr.length; j++) {
            var bucket = parseInt((arr[j] % mod) / dev);
            if(counter[bucket]==null) {
                counter[bucket] = [];
            }
            counter[bucket].push(arr[j]);
        }
        var pos = 0;
        for(var j = 0; j &lt; counter.length; j++) {
            var value = null;
            if(counter[j]!=null) {
                while ((value = counter[j].shift()) != null) {
                      arr[pos++] = value;
                }
          }
        }
    }
    return arr;
}

</code></pre></div><p>参考文章：<br> <a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/onepixel/articles/7674659.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <a href="https://www.cnblogs.com/twobin/p/3378302.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/twobin/p/3378302.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/kw-blog/Flutter/Flutter路由.html" class="prev">
        Flutter路由
      </a></span> <span class="next"><a href="/kw-blog/vr/图像基础篇.html">
        图像基础篇
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/kw-blog/assets/js/app.b958d4e2.js" defer></script><script src="/kw-blog/assets/js/2.1e882bb7.js" defer></script><script src="/kw-blog/assets/js/3.f163c3d7.js" defer></script>
  </body>
</html>

(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{431:function(t,e,a){"use strict";a.r(e);var s=a(56),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"什么是webrtc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是webrtc"}},[t._v("#")]),t._v(" 什么是WebRTC")]),t._v(" "),a("p",[t._v("WebRTC（全称 Web Real-Time Communication），即网页实时通信。 是一个支持网页浏览器进行实时语音对话或视频对话的技术方案。从前端技术开发的视角来看，是一组可调用的API标准。这个技术可以使很多不同的应用，如视频会议、文件传输、聊天和桌面共享等都不需要额外的插件。")]),t._v(" "),a("h2",{attrs:{id:"我们为何要建立-webrtc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#我们为何要建立-webrtc"}},[t._v("#")]),t._v(" 我们为何要建立 WebRTC？")]),t._v(" "),a("p",[t._v("建立它的理由是人们需要用一种标准的、低延迟的方式来传递媒体数据（视频&音频）。\n所谓“标准的”意味着我们需要简单易使用的 API。而所谓“低延迟的”意味着需要一种合适的协议，UDP 显然是一个好的选择，因为 UDP 没有过多的应答过程（Acknowledgment）。但我们需要的协议要比 UDP 更好，要能支持 P2P 的通信。因为一旦依赖服务器来传递内容就会因为反向代理或者穿透引入额外的延迟，用户需要进行终止、观察、处理、转化流等操作，这些都会造成额外消耗。对于视频传输、特别是直播、会话等场景，用户希望内容到达得越快越好，所以 P2P 是最快的路径。")]),t._v(" "),a("p",[t._v("此外，WebRTC 也旨在实现浏览器之间丰富的沟通。浏览器已经发展了很长时间，它“拥有”大量的优质资源，它可以访问摄像头和麦克风，这些特性都值得被开发利用。用户不需要写自己的应用，而是基于 WebRTC 的标准 API 便可以轻松使用。不仅是浏览器，在移动设备和 IoT 设备通信时也同样。")]),t._v(" "),a("h2",{attrs:{id:"webrtc-的关键技术和概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webrtc-的关键技术和概念"}},[t._v("#")]),t._v(" WebRTC 的关键技术和概念")]),t._v(" "),a("h3",{attrs:{id:"nat-network-address-translation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nat-network-address-translation"}},[t._v("#")]),t._v(" NAT（Network Address Translation）")]),t._v(" "),a("p",[t._v("如下图所示的示例中：路由器有一个 Public IP 5.5.5.5，也有一个 Private IP 10.0.0.1（也被称为 gateway），你的机器只有一个 Private IP 10.0.0.2，但你想要访问 IP 为 4.4.4.4:80 的机器，要如何实现呢？\n"),a("img",{attrs:{src:"https://pics0.baidu.com/feed/f11f3a292df5e0fee4ac9658b20137a45fdf72a4.jpeg@f_auto?token=c8a638eb63898476c9a89f6514fcb5a0",alt:"NAT"}})]),t._v(" "),a("p",[t._v("首先：你的机器会构建一个数据包，声明想向 4.4.4.4:80 发出 GET 请求，10.0.0.2 是源 IP 地址。接下来：你的机器会通过子网掩码判断是否可以直接与 4.4.4.4:80 进行连接，运算结果会显示 4.4.4.4:80 并不在你所在的子网中，因此无法直接进行通信。所以下一步就需要将请求发送给路由器，借助 gateway 进行通信。路由器会替换源 IP 地址和端口为 Public IP 和一个随机端口，但在此之前会创建 NAT 表，来记录三者之间的对应关系。这样对端就能收到你的GET请求，并进行后续处理了（如下图所示）。\n"),a("img",{attrs:{src:"https://pics5.baidu.com/feed/e7cd7b899e510fb3788dd3920252cb99d0430c88.jpeg@f_auto?token=0c134da2c3411dcaaf67d1fe64c243d1",alt:"NAT"}})]),t._v(" "),a("p",[t._v("在这之后：服务器 4.4.4.4:80 将向你的机器发送回复，工作原理和上述相同，根据 NAT 表查询对应地址完成通信（如下图所示）。\n"),a("img",{attrs:{src:"https://pics5.baidu.com/feed/9c16fdfaaf51f3de94f91f434f8ff3133a29793f.jpeg@f_auto?token=fa06fcecdd06eab91edfac1efc403de0",alt:"NAT"}})]),t._v(" "),a("p",[t._v("NAT 的转换方式主要有以下几种：\n1）一对一 NAT（完全圆锥型 NAT）：One to One NAT（Full-cone NAT） 路由器上要发送到外部 IP:port 的数据包总是可以映射到内部 IP:port ，无一例外。举例说明，所有发送到 5.5.5.5:3333 的数据包总是会被自动转发到 10.0.0.2:8992，无论这个包是来自 4.4.4.4:80 或者其他任何地址。")]),t._v(" "),a("p",[t._v("2）IP 受限型 NAT：Address restricted NAT 出于安全考虑，部分路由器会地址限制，考虑之前是否与该地址进行过通信。即路由器上要发送到外部 IP:port 的数据包可以映射到内部 IP:port，前提是数据包的源地址与 NAT 表相符，无所谓端口是什么。举例说明，发送到 5.5.5.5:3333 的数据包中，只有源 IP 是 4.4.4.4 或其他表中有过记录的 IP 才会被自动转发到 10.0.0.2:8992，即使这个 IP 之前并不是和 3333 端口进行的通信。")]),t._v(" "),a("p",[t._v("3）端口受限型 NAT：Port restricted NAT 与前者相比，增加了端口限制，即路由器上要发送到外部 IP:port 的数据包可以映射到内部 IP:port，前提是数据包的源 IP 和 Port 都要与 NAT 表相符。举例说明，发送到 5.5.5.5:3333 的数据包中，只有来自 4.4.4.4:80 或其他表中有过记录的 IP: Port 才会被自动转发到 10.0.0.2:8992，即使这个 IP: Port 之前并不是和 3333 端口进行的通信。")]),t._v(" "),a("p",[t._v("4）对称 NAT：Symmetric NAT 该方式是限制最多的一种，即必须匹配完整的 IP:port，区别在于发送到 5.5.5.5:3333 的数据包中，只有来自 4.4.4.4:80 的才会被自动转发到 10.0.0.2:8992，其他的包均无法通过。这种方式无法在 WebRTC 中使用，因为 WebRTC 需要 STUN 服务器。一旦 STUN 服务器建立了一个 Public 代表，Symmetric NAT 要求只能与一个特定的对端通信，这种限制不适合 WebRTC。")]),t._v(" "),a("h3",{attrs:{id:"stun-session-traversal-utilities-for-nat"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#stun-session-traversal-utilities-for-nat"}},[t._v("#")]),t._v(" STUN（Session Traversal Utilities for NAT）")]),t._v(" "),a("p",[t._v("STUN 是可以赋予一个应用程序所需要的 Public IP 和 Port，适用于 Full-cone、Address restricted 和 Port restricted NAT，无法用于 Symmetric NAT。\nSTUN 服务器通常在 3478 端口上运行，TLS 端口为 5349。\nSTUN 是非常轻量级的，用户可以使用 docker 建立一个 STUN 服务器。\nSTUN 服务器的目的就是让用户找到自己的 Public 表示，并通过这个 Public 表示与其他用户进行通信。如果我们使用的是像大约 1996 年或 2000 年早期时那样的 Public IP 地址，通信也将非常简单。但就现在而言，我们必须使用 STUN 服务器。\nSTUN 服务器的工作流程如下图所示：\n"),a("img",{attrs:{src:"https://pics7.baidu.com/feed/8c1001e93901213fbb68e61a8e8635dd2e2e950e.jpeg@f_auto?token=808edc61325f682fed9b04b0d6e977da0",alt:"STUN"}})]),t._v(" "),a("p",[t._v("首先创建一个数据包进行 STUN 请求：STUN 服务器的地址为 9.9.9.9:3478，同样在路由器创建了 NAT 表并进行了地址转换，然后数据包被送到了 STUN 服务器。")]),t._v(" "),a("p",[t._v("服务器收到请求后：为 10.0.0.2 的机器构建了一个 Public 表示 5.5.5.5:3333，并把这个信息打包进一个数据包进行反馈。\n"),a("img",{attrs:{src:"https://pics5.baidu.com/feed/e61190ef76c6a7ef50728cfa279bac5df2de6607.jpeg@f_auto?token=ae4a670e8ed414df17379d6805796925",alt:"STUN"}})]),t._v(" "),a("p",[t._v("上述是一个 STUN 请求的详细过程，以下图为例，STUN 在整个通信过程中进行了以下工作：首先给予 10.0.0.2 的机器一个 Public 表示 5.5.5.5:3333，同时给予 192.168.1.2 的机器一个 Public 表示 7.7.7.7:4444。随后二者都使用获得的 Public 表示进行连接。\n"),a("img",{attrs:{src:"https://pics6.baidu.com/feed/b03533fa828ba61ebe0d43c49b559406324e59e3.jpeg@f_auto?token=a3b2e5abbefa7d4e34a7cbdc32a40f9f5",alt:"STUN"}})]),t._v(" "),a("h3",{attrs:{id:"turn-traversal-using-relays-around-nat"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#turn-traversal-using-relays-around-nat"}},[t._v("#")]),t._v(" TURN（Traversal Using Relays around NAT）")]),t._v(" "),a("p",[t._v("在应用 Symmetric NAT 的情况下，必须使用 TURN。\n所有的通信内容都要经过 TURN 服务器的转发，所以 TURN 服务器的维护成本比较高，这也是为什么几乎没有人免费提供这种服务器供用户使用。\n下图是一个 TURN 服务器工作流程的示例，二者之间并不是直接的 P2P 通信，所有的信息都经过了 TURN 服务器进行转发。\n"),a("img",{attrs:{src:"https://pics3.baidu.com/feed/a8773912b31bb0515b1f0cf6ec1bd9b84bede0a7.jpeg@f_auto?token=efcc15d9411f669b3d1d970bdcddf189",alt:"STUN"}})]),t._v(" "),a("h3",{attrs:{id:"ice-interactive-connectivity-establishment"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ice-interactive-connectivity-establishment"}},[t._v("#")]),t._v(" ICE（Interactive Connectivity Establishment）")]),t._v(" "),a("p",[t._v("在建立了很多 STUN 和 TURN 服务器后，从 A 到 B 之间的路径有了非常多的选择，为了更好的处理这些路径，人们提出了 ICE。\nICE 会收集所有可用的通信路径作为“候选人”（ICE Candidates），有可能是本地 IP 地址、STUN 和 TURN 服务器提供的地址等等。收集到的所有地址都将放入 SDP 中，再送到对端，对端通过解析 SDP 来了解我方提供的重要信息。\n因此，ICE 是 WebRTC 中非常关键的组成部分。")]),t._v(" "),a("h3",{attrs:{id:"sdp-session-description-protocol"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sdp-session-description-protocol"}},[t._v("#")]),t._v(" SDP（Session Description Protocol）")]),t._v(" "),a("p",[t._v("SDP 是一种用于表述 ICE Candidates 的格式，它描述了网络选项、媒体选项、安全选项和其他很多信息，开发者甚至可以自定义 SDP 内容。\n实际上 SDP 并不是一种协议，只是一种数据格式，但 SDP 是 WebRTC 中最重要的几个概念之一。它的设计目的是将用户产生的 SDP 送至其他端，送的方式并不关心。")]),t._v(" "),a("h3",{attrs:{id:"signaling-信令交换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#signaling-信令交换"}},[t._v("#")]),t._v(" Signaling（信令交换）")]),t._v(" "),a("p",[t._v("Signaling 过程是将用户产生的 SDP 通过某种方式传递给想要通信的那方。\n如上所述，以何种方式传递并不重要。很多人通过 WebSocket 或者 socket.io 来传递 SDP 信息，这个过程就是 Signal SDP。\n尽管要找到所有的 ICE candidate 是耗费时间的，但一旦完成了这个过程，下一步就是创建一个 SDP，进而生成一个 QR code 并把 QR code 公布到 twitter 上，其他人扫描了这个二维码就可以获取相应的 SDP。\n这个过程是通过 twitter、QR code、Whatsapp、WebSockets、还是 HTTP 请求都不重要，因为实际上就是将一个长字符串传递给其他人罢了。\n简而言之，Signaling 就是将 SDP 信息传递给另外一方。")]),t._v(" "),a("p",[t._v("一个典型的WebRTC通信流程是这样的：\n1）A 想要和B建立连接；\n2）A 创建了一个 offer，它寻找所有的 ICE candidate、安全选项、音视频选项等并创建 SDP（简单来说这个 offer 就是 SDP）；\n3）A 将 SDP 信令传递给 B（Signaling）；\n4）B 根据 A 的 offer 进行设置，并创建应答（answer）；\n5）B 将 Answer 信令传递给 A（Signaling）；\n6）连接建立。")])])}),[],!1,null,null,null);e.default=r.exports}}]);
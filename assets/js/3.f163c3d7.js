(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{398:function(r,n,t){r.exports=t.p+"assets/img/1.d72e2827.png"},399:function(r,n,t){r.exports=t.p+"assets/img/2.ca63e7e7.png"},400:function(r,n,t){r.exports=t.p+"assets/img/1.33a947c7.gif"},401:function(r,n,t){r.exports=t.p+"assets/img/2.1c7e20f3.gif"},402:function(r,n,t){r.exports=t.p+"assets/img/3.91b76e8e.gif"},403:function(r,n,t){r.exports=t.p+"assets/img/4.671bd19a.gif"},404:function(r,n,t){r.exports=t.p+"assets/img/5.cdda3f11.gif"},405:function(r,n,t){r.exports=t.p+"assets/img/6.c411339b.gif"},406:function(r,n,t){r.exports=t.p+"assets/img/7.7073c729.gif"},407:function(r,n,t){r.exports=t.p+"assets/img/8.3a6f1e50.gif"},429:function(r,n,t){"use strict";t.r(n);var a=t(56),e=Object(a.a)({},(function(){var r=this,n=r.$createElement,a=r._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[a("h2",{attrs:{id:"最常见的八大排序算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最常见的八大排序算法"}},[r._v("#")]),r._v(" 最常见的八大排序算法")]),r._v(" "),a("p",[r._v("说到数据结构和算法，最基础的便是八大排序和三大查找了，所谓排序，无非是按照一定规则将一组数据从无序变成有序。\n本篇文章主要是介绍八大排序算法，首先对这八种排序算法分类如下：")]),r._v(" "),a("p",[a("img",{attrs:{src:t(398),alt:"排序算法分类"}})]),r._v(" "),a("p",[r._v("接下来是对以上八种排序的性能比较：")]),r._v(" "),a("p",[a("img",{attrs:{src:t(399),alt:"排序算法性能比较"}})]),r._v(" "),a("p",[r._v("从表中我们可以看到一项指标："),a("strong",[r._v("稳定性")]),r._v("。所谓稳定性，是指在待排序的序列中有多个相同项，在排序前和排序后它们的相对位置有没有发生变化。")]),r._v(" "),a("p",[r._v("举个栗子：\n幼儿园有十个小朋友，现在要将他们按身高进行排序，小明和小刚身高一样高，排序前小明站在小刚前面，如果排完序后小明还在小刚前面，那么排序就是稳定的，反之亦然。")]),r._v(" "),a("p",[r._v("一个用来记排序稳定性的小诀窍"),a("br"),r._v("\n“快些选堆”: 其中“快”指快速排序，“些”指希尔排序，“选”指选择排序，“堆”指堆排序，即这四种排序方法是不稳定的，其他自然都是稳定的。")]),r._v(" "),a("p",[r._v("接下来对这八种排序方式逐一讲解，示例中均按升序排列进行讲解，并附上代码（Javascript版）。")]),r._v(" "),a("h3",{attrs:{id:"冒泡排序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#冒泡排序"}},[r._v("#")]),r._v(" 冒泡排序")]),r._v(" "),a("blockquote",[a("p",[r._v("算法思想：\n通过一系列的“交换”动作完成，首先第一个元素与第二个元素比较，如果第一个大，则二者交换，否则不交换；然后第二个元素和第三个元素比较，如果第二个大，则二者交换，否则不交换，以此类推，最终最大的那个元素被交换到了最后，一趟冒泡排序完成。在这个过程中，大的元素就像一块石头一样沉底，小的元素逐渐向上浮动。冒泡排序算法结束的条件是一趟排序没有发生元素交换。")])]),r._v(" "),a("p",[a("img",{attrs:{src:t(400),alt:"冒泡排序"}})]),r._v(" "),a("p",[r._v("代码：")]),r._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[r._v("function bubbleSort(arr) {\n    var len = arr.length;\n    for (var i = 0; i < len - 1; i++) {\n        for (var j = 0; j < len - 1 - i; j++) {\n            if (arr[j] > arr[j+1]) {        \n                var temp = arr[j+1];        \n                arr[j+1] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n    return arr;\n}\n\n")])])]),a("h3",{attrs:{id:"选择排序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#选择排序"}},[r._v("#")]),r._v(" 选择排序")]),r._v(" "),a("blockquote",[a("p",[r._v("算法思想：\n初始时在序列中找到最小的元素，放到序列的起始位置作为已排序序列。然后再从剩余未排序元素中继续寻找最小元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。")])]),r._v(" "),a("p",[a("img",{attrs:{src:t(401),alt:"选择排序"}})]),r._v(" "),a("p",[r._v("代码：")]),r._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[r._v("function selectionSort(arr) {\n    var len = arr.length;\n    var minIndex, temp;\n    for (var i = 0; i < len - 1; i++) {\n        minIndex = i;\n        for (var j = i + 1; j < len; j++) {\n            if (arr[j] < arr[minIndex]) {     // 寻找最小的数\n                minIndex = j;                 // 将最小数的索引保存\n            }\n        }\n        temp = arr[i];\n        arr[i] = arr[minIndex];\n        arr[minIndex] = temp;\n    }\n    return arr;\n} \n\n")])])]),a("h3",{attrs:{id:"直接插入排序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#直接插入排序"}},[r._v("#")]),r._v(" 直接插入排序")]),r._v(" "),a("blockquote",[a("p",[r._v("算法思想：\n通过一系列的“插入”动作完成，首先第一个元素作为已排序序列，取出第二个元素，在已排序序列中从后往前扫描，如果该元素比第二个元素大，则将该元素往后移一位，然后再选中第三个元素重复上面的扫描操作，直到所有元素有序。")])]),r._v(" "),a("p",[a("img",{attrs:{src:t(402),alt:"插入排序"}})]),r._v(" "),a("p",[r._v("代码：")]),r._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[r._v("function insertionSort(arr) {\n    var len = arr.length;\n    var preIndex, current;\n    for (var i = 1; i < len; i++) {\n        preIndex = i - 1;\n        current = arr[i];\n        while (preIndex >= 0 && arr[preIndex] > current) {\n            arr[preIndex + 1] = arr[preIndex];\n            preIndex--;\n        }\n        arr[preIndex + 1] = current;\n    }\n    return arr;\n}\n\n")])])]),a("h3",{attrs:{id:"希尔排序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#希尔排序"}},[r._v("#")]),r._v(" 希尔排序")]),r._v(" "),a("blockquote",[a("p",[r._v("算法思想：\n希尔排序实际上是直接插入排序的改进版，将待排序序列按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。")])]),r._v(" "),a("p",[a("img",{attrs:{src:t(403),alt:"希尔排序"}})]),r._v(" "),a("p",[r._v("代码：")]),r._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[r._v("function shellSort(arr) {\n    var len = arr.length;\n    for (var gap = Math.floor(len / 2); gap > 0; gap = Math.floor(gap / 2)) {\n        // 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行\n        for (var i = gap; i < len; i++) {\n            var j = i;\n            var current = arr[i];\n            while (j - gap >= 0 && current < arr[j - gap]) {\n                 arr[j] = arr[j - gap];\n                 j = j - gap;\n            }\n            arr[j] = current;\n        }\n    }\n    return arr;\n}\n\n")])])]),a("h3",{attrs:{id:"归并排序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#归并排序"}},[r._v("#")]),r._v(" 归并排序")]),r._v(" "),a("blockquote",[a("p",[r._v("算法思想：\n归并排序是采用分治法的一种排序方式，将局部有序慢慢扩展到全部有序。先将无序序列对半分成两组，分别对这两组进行归并排序（逐层拆分，直到拆无可拆），然后再将这两个有序的数组合并成一个有序的数组。")])]),r._v(" "),a("p",[a("img",{attrs:{src:t(404),alt:"归并排序"}})]),r._v(" "),a("p",[r._v("代码：")]),r._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[r._v("function mergeSort(arr) {\n    var len = arr.length;\n    if (len < 2) {\n        return arr;\n    }\n    var middle = Math.floor(len / 2),\n        left = arr.slice(0, middle),\n        right = arr.slice(middle);\n    return merge(mergeSort(left), mergeSort(right));\n}\n \nfunction merge(left, right) {\n    var result = [];\n \n    while (left.length>0 && right.length>0) {\n        if (left[0] <= right[0]) {\n            result.push(left.shift());\n        } else {\n            result.push(right.shift());\n        }\n    }\n \n    while (left.length)\n        result.push(left.shift());\n \n    while (right.length)\n        result.push(right.shift());\n \n    return result;\n}\n\n")])])]),a("h3",{attrs:{id:"快速排序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#快速排序"}},[r._v("#")]),r._v(" 快速排序")]),r._v(" "),a("blockquote",[a("p",[r._v("算法思想：\n快速排序也是采用分治法的另一种排序方式，先从无序序列中选出一个元素作为基准，然后将序列中所有比基准数（pivot）小的元素放在基准数前面，将所有比基准数（pivot）大的元素放在基准数后面；然后递归的将基准数前的无序序列进行同样的操作（基准数后面的无序序列也要），直到最终该序列有序。")])]),r._v(" "),a("p",[a("img",{attrs:{src:t(405),alt:"快速排序"}})]),r._v(" "),a("p",[r._v("代码：")]),r._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[r._v("function quickSort(arr, left, right) {\n    var len = arr.length,\n        partitionIndex,\n        left = typeof left != 'number' ? 0 : left,\n        right = typeof right != 'number' ? len - 1 : right;\n \n    if (left < right) {\n        partitionIndex = partition(arr, left, right);\n        quickSort(arr, left, partitionIndex-1);\n        quickSort(arr, partitionIndex+1, right);\n    }\n    return arr;\n}\n \nfunction partition(arr, left ,right) {     // 分区操作\n    var pivot = left,                      // 设定基准值（pivot）\n        index = pivot + 1;\n    for (var i = index; i <= right; i++) {\n        if (arr[i] < arr[pivot]) {\n            swap(arr, i, index);\n            index++;\n        }       \n    }\n    swap(arr, pivot, index - 1);\n    return index-1;\n} \n \nfunction swap(arr, i, j) {\n    var temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n\n")])])]),a("h3",{attrs:{id:"堆排序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#堆排序"}},[r._v("#")]),r._v(" 堆排序")]),r._v(" "),a("p",[r._v("堆的定义：\n1.堆的每一个父节点都大于（或小于）其子节点；\n2.堆的每个左子树或者右子树也是一个堆；")]),r._v(" "),a("blockquote",[a("p",[r._v("算法思想：\n堆排序实际上是利用堆这种数据结构设计的一种排序算法，堆是一种近似完全二叉树的数据结构；堆排序实际上是建立大顶堆（或小顶堆）的过程；")])]),r._v(" "),a("ol",[a("li",[r._v("将初始待排序关键字序列(R1,R2....Rn)构建成大顶堆，此堆为初始的无序区；")]),r._v(" "),a("li",[r._v("将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,......Rn-1)和新的有序区(Rn),且满足R[1,2...n-1]<=R[n];")]),r._v(" "),a("li",[r._v("由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,......Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2....Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。")])]),r._v(" "),a("p",[a("img",{attrs:{src:t(406),alt:"堆排序"}})]),r._v(" "),a("p",[r._v("代码：")]),r._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[r._v("var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量\n \nfunction buildMaxHeap(arr) {   // 建立大顶堆\n    len = arr.length;\n    for (var i = Math.floor(len/2); i >= 0; i--) {\n        heapify(arr, i);\n    }\n}\n \nfunction heapify(arr, i) {     // 堆调整\n    var left = 2 * i + 1,\n        right = 2 * i + 2,\n        largest = i;\n \n    if (left < len && arr[left] > arr[largest]) {\n        largest = left;\n    }\n \n    if (right < len && arr[right] > arr[largest]) {\n        largest = right;\n    }\n \n    if (largest != i) {\n        swap(arr, i, largest);\n        heapify(arr, largest);\n    }\n}\n \nfunction swap(arr, i, j) {\n    var temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n \nfunction heapSort(arr) {\n    buildMaxHeap(arr);\n \n    for (var i = arr.length - 1; i > 0; i--) {\n        swap(arr, 0, i);\n        len--;\n        heapify(arr, 0);\n    }\n    return arr;\n}\n")])])]),a("h3",{attrs:{id:"基数排序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基数排序"}},[r._v("#")]),r._v(" 基数排序")]),r._v(" "),a("blockquote",[a("p",[r._v("算法思想\n基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。")])]),r._v(" "),a("p",[a("img",{attrs:{src:t(407),alt:"基数排序"}})]),r._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[r._v("var counter = [];\nfunction radixSort(arr, maxDigit) {\n    var mod = 10;\n    var dev = 1;\n    for (var i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) {\n        for(var j = 0; j < arr.length; j++) {\n            var bucket = parseInt((arr[j] % mod) / dev);\n            if(counter[bucket]==null) {\n                counter[bucket] = [];\n            }\n            counter[bucket].push(arr[j]);\n        }\n        var pos = 0;\n        for(var j = 0; j < counter.length; j++) {\n            var value = null;\n            if(counter[j]!=null) {\n                while ((value = counter[j].shift()) != null) {\n                      arr[pos++] = value;\n                }\n          }\n        }\n    }\n    return arr;\n}\n\n")])])]),a("p",[r._v("参考文章："),a("br"),r._v(" "),a("a",{attrs:{href:"https://www.cnblogs.com/onepixel/articles/7674659.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("https://www.cnblogs.com/onepixel/articles/7674659.html"),a("OutboundLink")],1),r._v(" "),a("a",{attrs:{href:"https://www.cnblogs.com/twobin/p/3378302.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("https://www.cnblogs.com/twobin/p/3378302.html"),a("OutboundLink")],1)])])}),[],!1,null,null,null);n.default=e.exports}}]);
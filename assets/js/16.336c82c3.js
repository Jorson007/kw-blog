(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{432:function(e,a,t){"use strict";t.r(a);var r=t(56),n=Object(r.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"什么是webpak"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是webpak"}},[e._v("#")]),e._v(" 什么是webpak")]),e._v(" "),t("blockquote",[t("p",[e._v("本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。原理参考下图；")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic2.zhimg.com%2Fv2-0f051d5dcbb95cb866e1b97fbc9ebd97_1440w.jpg%3Fsource%3D172ae18b&refer=http%3A%2F%2Fpic2.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1650723647&t=c323381f393617602a507015e16de7ee",alt:"webpack原理图"}})]),e._v(" "),t("blockquote",[t("p",[e._v("从图中我们可以看出，Webpack 可以将多种静态资源 js、css、less 转换成一个静态文件，减少了页面的请求。")])]),e._v(" "),t("h2",{attrs:{id:"webpak解决了什么问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpak解决了什么问题"}},[e._v("#")]),e._v(" webpak解决了什么问题")]),e._v(" "),t("blockquote",[t("p",[e._v("随着前端项目的规模和复杂度逐渐增大，所依赖的工具和框架也越来越丰富，在这个过程中会遇到以下问题：react的jsx代码必须编译后才能在浏览器中使用，浏览器不支持sass和less代码等。这个时候就需要一个工具对我们的项目进行编译、合并、打包，最终生成可被浏览器识别的静态文件。类似的工具还有Grunt和Gulp。")])]),e._v(" "),t("h2",{attrs:{id:"webpak核心概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpak核心概念"}},[e._v("#")]),e._v(" webpak核心概念")]),e._v(" "),t("h3",{attrs:{id:"重要参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重要参数"}},[e._v("#")]),e._v(" 重要参数")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("* entry\n    项目打包的入口文件，指从哪一个文件开始打包，支持单入口和多入口\n* output\n    打包生成的文件配置，告诉webpack在哪里输出它所创建的静态文件,以及如何命名这些文件\n* module\n    模块，在webpack里一切皆模块，一个模块对应着一个文件\n* chunk\n    多个文件组成一个代码块。可以将可执行的模块和他所依赖的模块组合成一个chunk\n* loader\n    loader可以将所有类型的文件转换为webpack能够处理的有效模块，然后你就可以利用webpack的打包能力，对它们进行处理。例如把es6转为es5，scss转为css等\n* plugin\n    webpack构建的生命周期节点上加入扩展hook，添加功能\n")])])]),t("h3",{attrs:{id:"webpack构建流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack构建流程"}},[e._v("#")]),e._v(" webpack构建流程")]),e._v(" "),t("p",[e._v("从启动构建到输出结果一系列过程：")]),e._v(" "),t("p",[e._v("（1）初始化参数：解析webpack配置参数，合并shell传入和webpack.config.js文件配置的参数，形成最后的配置结果。")]),e._v(" "),t("p",[e._v("（2）开始编译：上一步得到的参数初始化compiler对象，注册所有配置的插件，插件监听webpack构建生命周期的事件节点，做出相应的反应，执行对象的 run 方法开始执行编译。")]),e._v(" "),t("p",[e._v("（3）确定入口：从配置的entry入口，开始解析文件构建AST语法树，找出依赖，递归下去。")]),e._v(" "),t("p",[e._v("（4）编译模块：递归中根据文件类型和loader配置，调用所有配置的loader对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。")]),e._v(" "),t("p",[e._v("（5）完成模块编译并输出：递归完事后，得到每个文件结果，包含每个模块以及他们之间的依赖关系，根据entry配置生成代码块chunk。")]),e._v(" "),t("p",[e._v("（6）输出完成：输出所有的chunk到文件系统。")]),e._v(" "),t("h3",{attrs:{id:"webpack配置示例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack配置示例"}},[e._v("#")]),e._v(" webpack配置示例")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    const path = require('path');\n    const HtmlWebpackPlugin = require('html-webpack-plugin'); \n    module.exports = {\n        entry: './path/to/my/entry/file.js',\n        output: {\n            path: path.resolve(__dirname, 'dist'),    //生成的bundle.js存放的位置\n            filename: 'my-first-webpack.bundle.js'\n        },\n        module: {\n            rules: [\n                { test: /\\.txt$/, use: 'raw-loader' }  //对应不同类型的文件使用不同的loader进行转换\n            ]\n        },\n        plugins: [\n            new HtmlWebpackPlugin({template: './src/index.html'})\n        ]\n    };\n\n")])])]),t("h3",{attrs:{id:"webpack构建流程-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack构建流程-2"}},[e._v("#")]),e._v(" webpack构建流程")]),e._v(" "),t("p",[e._v("webpack的构建流程可以分为以下三大阶段：")]),e._v(" "),t("p",[e._v("初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler。\n编译：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理。\n输出：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统。")]),e._v(" "),t("h2",{attrs:{id:"webpak一些问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpak一些问题"}},[e._v("#")]),e._v(" webpak一些问题")]),e._v(" "),t("ol",[t("li",[e._v("webpack与grunt、gulp的不同？")]),e._v(" "),t("li",[e._v("有哪些常见的Loader，它们是用来干嘛的？")]),e._v(" "),t("li",[e._v("有哪些常见的Plugin？他们是用来干嘛的？")]),e._v(" "),t("li",[e._v("webpack的热更新是如何做到的？原理是什么？")]),e._v(" "),t("li",[e._v("如何利用webpack来优化前端性能?")]),e._v(" "),t("li",[e._v("如何提高webpack的构建速度?")])]),e._v(" "),t("p",[e._v("以上这些问题都能在参考文章里找到，感兴趣的小伙伴可以查阅哟～")]),e._v(" "),t("p",[e._v("参考：")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://www.cnblogs.com/chengxs/p/11022842.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.cnblogs.com/chengxs/p/11022842.html"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://webpack.wuhaolin.cn",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://webpack.wuhaolin.cn"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/37864523",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://zhuanlan.zhihu.com/p/37864523"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://www.webpackjs.com",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.webpackjs.com"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=n.exports}}]);
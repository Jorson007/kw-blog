(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{442:function(n,t,e){"use strict";e.r(t);var a=e(56),s=Object(a.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p",[n._v("mutating单词翻译过来有“可变化，可改变”的意思。它主要用在Swift中的：")]),n._v(" "),e("p",[n._v("结构体（struct）、枚举（enum）\n扩展（extension）、协议（protocol）中修饰方法\nSwift结构体（struct）、枚举（enum） 中均可以包含类方法和实例方法")]),n._v(" "),e("p",[n._v("Swift官方是不建议在结构体（struct）、枚举（enum）的普通方法里修改属性变量。")]),n._v(" "),e("p",[n._v("但是，在方法前面添加 mutating 关键字之后就可以在对应的 mutating代理方法内修改。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('protocol Person {\n    var age: Int {get}\n    var name: String {get set}\n    mutating func changeName()\n}\n \nstruct Men: Person {\n    let age = 14\n    var name = "李华"\n    mutating func changeName() {\n        name = "张三"\n    }\n}\n\n')])])]),e("p",[n._v("这段代码中不加mutating关键字，编译器就会报错。如果不实现changeName方法，保持现有代码不变 的话，会报错说没有实现协议。如果去掉 mutating 的话，会报错说不能改变结构体成员。")]),n._v(" "),e("p",[n._v("示例2：")]),n._v(" "),e("p",[n._v("为String添加一个extention 实现appendString(string: String)")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("extension String {\n \n    mutating func appendString(string: String) {\n \n        self = self.stringByAppendingString(string)\n    }\n}\n")])])]),e("p",[n._v("另外，在使用 class 来实现带有 mutating 的方法的协议时，方法前面是不需要加 mutating 修饰的，因为 class 可以随意更改自己的成员变量。因此在协议里用 mutating 修饰方法，对于 class 的实现是完全透明，可以当作不存在的。")])])}),[],!1,null,null,null);t.default=s.exports}}]);
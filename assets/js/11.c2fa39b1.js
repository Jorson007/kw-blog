(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{420:function(t,v,_){t.exports=_.p+"assets/img/zujianhua.3bbe046c.jpg"},439:function(t,v,_){"use strict";_.r(v);var p=_(56),o=Object(p.a)({},(function(){var t=this,v=t.$createElement,p=t._self._c||v;return p("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[p("h2",{attrs:{id:"ios模块化"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#ios模块化"}},[t._v("#")]),t._v(" iOS模块化")]),t._v(" "),p("p",[t._v("随着团队成员扩张以及项目日益庞大，如何提高团队的产出效率，同时降低项目之间的耦合性，以减少牵一发而动全身的问题出现，组件化和模块化成为我们的首选。最近跟这团队一起学习了组件化的实践方案，有一些心得体会，为了能更好的实践组件化方案，于是决定自己写一个小项目进行练手。")]),t._v(" "),p("p",[t._v("首先组件化有什么优势呢？\n1.模块间解藕；\n2.模块可以复用；\n3.方便进行单元测试；\n4.提升团队协作开发效率；")]),t._v(" "),p("p",[t._v("说到组件化和模块化，很多小伙伴傻傻分不清，也有很多人认为组件化就是模块化，对于这个问题我觉得仁者见仁、智者见智。我是这样理解的，首先，我们不论是一个系统还是一个APP，肯定是会有多个模块的，如登陆模块、首页模块、个人信息模块等。而我们不同的模块可能都会用到同样的组件，如：富文本组件、网络组建、UI组件等。那么我们在进行模块化或者组件化的时候，可以按照下图进行分层：")]),t._v(" "),p("p",[p("img",{attrs:{src:_(420),alt:"zujianjiagou"}})]),t._v(" "),p("p",[t._v("从上图可以看到，一般我们的组件化方案分三层：业务层、通用层、基础层，要注意的是，只有上层可以依赖下层，下层不可依赖上层，同时横向依赖要尽可能少。")]),t._v(" "),p("p",[t._v("组件化方案")]),t._v(" "),p("p",[t._v("当前通用的组件化方案主要分两种：本地组件化和cocoapods组件化")]),t._v(" "),p("p",[t._v("本地组件化")]),t._v(" "),p("p",[t._v("步骤1: 创建主工程")]),t._v(" "),p("p",[t._v("集成cocoapods，进行本地管理，执行指令pod init")]),t._v(" "),p("p",[t._v("编辑podfile，并执行pod install")]),t._v(" "),p("p",[t._v("步骤2: 创建模块A、模块B")]),t._v(" "),p("p",[t._v("创建的每一个模块记得修改他的变异类型为静态库")]),t._v(" "),p("p",[t._v("模块化方案主要分以下三种：")]),t._v(" "),p("p",[t._v("url跳转：主要用于页面跳转\nprotocol注册：用于注册服务\n通知")])])}),[],!1,null,null,null);v.default=o.exports}}]);
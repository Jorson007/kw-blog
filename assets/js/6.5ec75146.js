(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{412:function(n,e,t){n.exports=t.p+"assets/img/coderesign1.4d2a303e.png"},413:function(n,e,t){n.exports=t.p+"assets/img/codesign2.b36d35b5.png"},414:function(n,e,t){n.exports=t.p+"assets/img/coderesign4.52ab53bb.png"},435:function(n,e,t){"use strict";t.r(e);var a=t(56),p=Object(a.a)({},(function(){var n=this,e=n.$createElement,a=n._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("p",[n._v("最近在学习iOS逆向相关的技术，首先就是得了解签名与重签名。对于iOS开发者来说，重签名是一项比较重要的技能。")]),n._v(" "),a("h2",{attrs:{id:"ios签名机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ios签名机制"}},[n._v("#")]),n._v(" iOS签名机制")]),n._v(" "),a("p",[n._v("在了解重签名之前，先来看一下ipa包的签名机制，如下图：")]),n._v(" "),a("p",[a("img",{attrs:{src:t(412),alt:"重签名"}})]),n._v(" "),a("blockquote",[a("p",[n._v("流程如下：\n1. Mac 钥匙串访问 在本地生成一对公私钥钥匙对，下面默认为公钥L、私钥L（L：Local）。")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("2. Apple已有一对公私钥钥匙对，私钥A在Apple后台，公钥A内置到每一台iOS设备终端（A：Apple）。\n\n3. 上传公钥L至Apple后台，使用私钥A对公钥L进行数字签名生成签名证书.cer，同时使用私钥L对额外信息（使用什么证书打包、AppID、打包的App包含了哪些功能、可以在哪些设备上安装）进行签名生成描述文件Provisioning Profile，之后将.cer和Provisioning Profile下载安装到Mac机器上。\n\n4. 编译打包app，选择签名证书.cer，打包指令会自动找到该证书对应的私钥L（能匹配是因为钥匙对是成对出现的，前提是本地必须已经存在L私钥，也就是p12的安装），然后使用私钥L对app进行签名。\n\n5. 这些签名数据包含两部分：Mach-O可执行文件会把签名直接写入这个文件中，其他资源文件则会保存在_CodeSignature目录下。你可以将打包生成的.ipa文件另存为.zip，解压后对Payload文件夹中的.app文件右键、显示包内容，就可以看到签名数据。\n\n6. 另外签名过程中对于App内包含的动态库以及插件（Plugins、Watch、Frameworks文件夹），每一个都会单独进行一次签名，并生成各自的Mach-O可执行文件和_CodeSignature。\n\n7. 签名数据指代码内容、App包含的所有资源文件，只要其中有任何改动，都必须重新签名才有效。\n打包的过程中会将描述文件Provisioning Profile命名为embedded.mobileprovision放入到打包app中。\n\n8. 安装/启动，iOS设备使用内置的公钥A验证embedded.mobileprovision是否有效（设备是否在允许安装列表内），同时再次验证里面包含的.cer证书签名是否有效（证书过期与否）并取出公钥L。\n\n9. embedded.mobileprovision验证通过，就使用公钥L解密验证app签名信息：AppID是否对应、权限开关是否跟app里的entitlements一致等等。\n")])])]),a("h2",{attrs:{id:"ipa包重签名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ipa包重签名"}},[n._v("#")]),n._v(" ipa包重签名")]),n._v(" "),a("p",[n._v("ipa包重签名主要针对的是非App Store的安装包，App Store分发最终是上传ipa文件到苹果后台审核，通过后使用Apple私钥加密，然后才能发布安装，不存在重签入侵的可能。而开发调试、AD-Hoc、In-House等分发途径生成的ipa包不存在苹果后台验证的步骤，这也就意味着你可以对任意的.app、 .ipa文件进行重签名。")]),n._v(" "),a("p",[n._v("重签名过程")]),n._v(" "),a("p",[n._v("step1: 从 https://www.dumpapp.com/ 该网站中下载你所需要的重签名软件ipa包；")]),n._v(" "),a("p",[n._v("step2: xCode创建你的壳工程，比如我是用微信做测试，那么我就创建名为WeChat的工程；")]),n._v(" "),a("p",[n._v("step3: 在工程目录中新建一个APP文件夹，将下载的ipa包放在该文件夹中，如下图所示：")]),n._v(" "),a("p",[a("img",{attrs:{src:t(413),alt:"文件目录"}})]),n._v(" "),a("p",[n._v("step4: 从上图中我们看到工程目录下有一个appsign.sh脚本文件，实际上这是我们将重签名的步骤使用脚本一次执行完毕；")]),n._v(" "),a("p",[n._v("step5: 用XCode打开工程，在Build Phases中添加脚本")]),n._v(" "),a("p",[a("img",{attrs:{src:t(414),alt:"脚本"}})]),n._v(" "),a("p",[n._v("step6: 运行工程，第一次会闪退，在运行一次即可。")]),n._v(" "),a("p",[n._v("上面我们看到重签名的脚本如下：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('\n    # ${SRCROOT} 它是工程文件所在的目录\n    #资源文件夹\n    ASSETS_PATH="${SRCROOT}/APP"\n\n    #ipa包路径\n    TARGET_IPA_PATH="${ASSETS_PATH}/*.ipa"\n\n    #----------------------------------------\n    # 1. 解压IPA到Temp下\n\n    if [ ! -d "$ASSETS_PATH/Payload/" ]; then\n        unzip -oqq "$TARGET_IPA_PATH" -d "$ASSETS_PATH"\n    fi\n\n    # 拿到解压的临时的APP的路径\n    TEMP_APP_PATH=$(set -- "$ASSETS_PATH/Payload/"*.app;echo "$1")\n    # echo "路径是:$TEMP_APP_PATH"\n\n    #----------------------------------------\n    # 2. 将解压出来的.app拷贝进入工程下\n    # BUILT_PRODUCTS_DIR 工程生成的APP包的路径\n    # TARGET_NAME target名称\n    TARGET_APP_PATH="$BUILT_PRODUCTS_DIR/$TARGET_NAME.app"\n    echo "app路径:$TARGET_APP_PATH"\n\n    rm -rf "$TARGET_APP_PATH"\n    mkdir -p "$TARGET_APP_PATH"\n    cp -rf "$TEMP_APP_PATH/" "$TARGET_APP_PATH"\n\n    #----------------------------------------\n    # 3. 删除extension和WatchAPP.个人证书没法签名Extention\n    rm -rf "$TARGET_APP_PATH/PlugIns"\n    rm -rf "$TARGET_APP_PATH/Watch"\n\n    #----------------------------------------\n    # 4. 更新info.plist文件 CFBundleIdentifier\n    #  设置:"Set : KEY Value" "目标文件路径"\n    /usr/libexec/PlistBuddy -c "Set :CFBundleIdentifier $PRODUCT_BUNDLE_IDENTIFIER" "$TARGET_APP_PATH/Info.plist"\n\n    #----------------------------------------\n    # 5. 给MachO文件上执行权限\n    # 拿到MachO文件的路径\n    APP_BINARY=`plutil -convert xml1 -o - $TARGET_APP_PATH/Info.plist|grep -A1 Exec|tail -n1|cut -f2 -d\\>|cut -f1 -d\\<`\n    #上可执行权限\n    chmod +x "$TARGET_APP_PATH/$APP_BINARY"\n\n    #----------------------------------------\n    # 6. 重签名第三方 FrameWorks\n    TARGET_APP_FRAMEWORKS_PATH="$TARGET_APP_PATH/Frameworks"\n    if [ -d "$TARGET_APP_FRAMEWORKS_PATH" ];\n    then\n    for FRAMEWORK in "$TARGET_APP_FRAMEWORKS_PATH/"*\n    do\n\n    #签名\n    /usr/bin/codesign --force --sign "$EXPANDED_CODE_SIGN_IDENTITY" "$FRAMEWORK"\n    done\n    fi\n\n')])])]),a("p",[n._v("至此iOS的重签名介绍完毕，同时附上一些关于重签名相关的优秀博客"),a("br")]),n._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://blog.csdn.net/iOSTeam37/article/details/122331504",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://blog.csdn.net/iOSTeam37/article/details/122331504"),a("OutboundLink")],1)]),n._v(" "),a("li",[a("a",{attrs:{href:"https://huoshan.blog.csdn.net/article/details/71598459",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://huoshan.blog.csdn.net/article/details/71598459"),a("OutboundLink")],1)]),n._v(" "),a("li",[a("a",{attrs:{href:"https://blog.csdn.net/jishulaozhuanjia/article/details/104801290",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://blog.csdn.net/jishulaozhuanjia/article/details/104801290"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=p.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{415:function(t,e,n){t.exports=n.p+"assets/img/chongpai1.e0946463.png"},416:function(t,e,n){t.exports=n.p+"assets/img/chongpai2.4c2e56fe.png"},417:function(t,e,n){t.exports=n.p+"assets/img/chongpai3.68160001.png"},418:function(t,e,n){t.exports=n.p+"assets/img/chongpai4.652d835c.png"},419:function(t,e,n){t.exports=n.p+"assets/img/chongpai5.6ca2987a.png"},438:function(t,e,n){"use strict";n.r(e);var s=n(56),a=Object(s.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"物理内存和虚拟内存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#物理内存和虚拟内存"}},[t._v("#")]),t._v(" 物理内存和虚拟内存")]),t._v(" "),s("blockquote",[s("p",[t._v("在早期的操作系统中，任何进程被加载到内存中运行时，都是按照顺序完全加载的。内存中的地址就是真实的物理地址，并且进程所需要的全部 指令和数据都是一次性加载到内存中。这样就会有出现两个明显的问题：\n"),s("strong",[t._v("数据安全问题")]),t._v(": 由于各个进程是按照顺序依次加载到内存中的，并且内存中的地址就是真实的物理地址。这样在一个进程中就可以内存地址偏移区访问到任意的内存空间，包括一些非当前进程的数据信息，这就导致进程本身的数据并不安全，给黑客造成了侵入的机会;\n"),s("strong",[t._v("内存浪费")]),t._v(": 由于每个进程都是完整加载的内存中的，所以随着进程的增多，内存的消耗会越来越严重，而事实上用户在同一时间操作用到一个进程，并且不太会一次性用到进进程中的所有功能，这就导致了严重的效率问题。\n于是引入了虚拟内存来解决以上问题，为了解决内存浪费的问题，虚拟内存是通过分页的方式来管理，一个进程的虚拟内存由很多个分页组成，启动APP的时候只需要按需加载所需要的分页，而不用把这个进程的内存都加载进来，大大节省了物理内存空间。同时为了解决安全性的问题，虚拟内存中的分页与污泥内存的分页之间存在一定的映射关系，而这种映射关系不是由进程决定的，而是由系统生成的，系统会维护一张内存映射表，当进程启动时由CPU去寻找虚拟内存中分页所对应的物理内存。")])]),t._v(" "),s("p",[t._v("传统进程与内存的关系：\n"),s("img",{attrs:{src:n(415),alt:"传统"}})]),t._v(" "),s("p",[t._v("引入虚拟内存后进程与内存的关系：\n"),s("img",{attrs:{src:n(416),alt:"虚拟"}})]),t._v(" "),s("p",[t._v("采用虚拟内存后，CPU访问进程数据的流程如下:")]),t._v(" "),s("ol",[s("li",[t._v("进程启动后，系统会为进程建立一个对应的虚拟内存，里面记录了进程每项数据的虚拟内存地址，此时进程还未加载到物理内存中，所以page记录\n的各项数据的物理内存地址为0x00000...。")]),t._v(" "),s("li",[t._v("当进程的某部分活跃后，CPU根据这部分数据的虚拟内存地址找到其对应的物理内存地址，再通过物理地址访问到物理内存上的数据。")]),t._v(" "),s("li",[t._v("如果在page上没有找到对应的物理地址时，说明此page上所关联的进程数据没被加载到物理内存中，此时会触发缺页异常（Page Fault），中断当前进程，先将当前页所对应的进程数据加载到物理内存中，然后page会记录每项数据的物理地址，CPU再通过物理地址来访问内存上的数据。")])]),t._v(" "),s("p",[t._v("从上面的进程流程中我们可以看到，到CPU在page上没有找到物理内存会造成缺页异常，而这种异常会中断进程，直到该分页被加载到物理内存中。虽然缺页异常造成的终端时间微乎其微，但是如果缺页终端次数过多也会导致进程阻塞。那么如何减少缺页中断呢？")]),t._v(" "),s("p",[t._v("首先我们知道APP在运行过程中其实很少会出现缺页异常的情况，只有在APP启动的时候需要为进程分配大量内存，如大量的方法调用和对象的初始化，这也就导致了APP启动时间变长。如果我们可以在APP启动过程中尽可能将调用的方法集中在较少的分页上，就会减少缺页中断的触发次数，也就能简短APP的启动时间。")]),t._v(" "),s("p",[t._v("在进行缺页中断优化之前，我们首先要知道我们APP在启动过程中出现了多少次缺页异常。\n那么就需要用到Instruments工具箱里面的System Trace，该工具可用来查看APP启动阶段缺页中断的触发次数。\n首先我们打开System Trace工具:\n"),s("img",{attrs:{src:n(417),alt:"虚拟"}})]),t._v(" "),s("p",[t._v("我使用自己做的一个项目做测试，统计APP启动过程中产生的缺页中断次数如下：\n"),s("img",{attrs:{src:n(418),alt:"虚拟"}})]),t._v(" "),s("p",[t._v("缺页中断次数:4577，耗时:760.61ms,因为该APP功能相对简单，所以可能优化空间不大，曾经拿微信的IPA包做过一个测试，发现其中断耗时达到了1.6s，当然微信的功能是非常庞大的，如果能够优化0.5s，对于用户来说也是能肉眼感受到的。接下来就讲如何通过二进制重排对APP启动时间进行优化。")]),t._v(" "),s("p",[t._v("首先需要查看APP启动过程中加载了哪些类和哪些方法，这个时候XCode给我们提供了一个分析神器：LinkMAp File。\n在编译阶段，每个类会生成对应的.o文件（目标文件）。在链接阶段，会把.o文件和动态库链接在一起。Link Map File就是这样一个记录链接相关信息的纯文本文件，里面记录了可执行文件的路径、CPU架构、目标文件、符号等信息。我们可以通过该文件查看启动过程中APP加载了哪些类和方法以及它们的顺序。LinkeMap不仅能用来进行二进制重排分析，也可以用来优化APP包体积。具体的使用方法以及原理参见附录。")]),t._v(" "),s("p",[t._v("通过配置APP的LinkMap文件，最终我们可以看到类和方法的大致加载顺序如下(截取了一部分)：\n"),s("img",{attrs:{src:n(419),alt:"虚拟"}})]),t._v(" "),s("p",[t._v("那么如何修改方法的加载顺序呢，XCode又提供了一个新的神器：通过设置Order File来认为干预编译期间的符号加载顺序。\n当然APP启动的时候会调用大量的方法，我们不可能手写.order文件，当然还需要一个工具将这些方法按照一定的规则输出，最好是直接能生成.order文件。\n目前比较通用的方法是fish hook,通过hook OC的message_send方法，输出对应的方法名，最终生成.order文件。当然这样的方法存在一些不足：如不能hook C++方法、block也hook不到。当然我们的优化不是一簇而成的。APP启动时间优化还有合并动态可、图片压缩等途径。")]),t._v(" "),s("p",[t._v("参考文档:"),s("br")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://www.jianshu.com/p/52e0dee35830",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.jianshu.com/p/52e0dee35830"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://blog.csdn.net/WangErice/article/details/1133492579",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://blog.csdn.net/WangErice/article/details/113349257"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://blog.csdn.net/jishulaozhuanjia/article/details/104801290",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://blog.csdn.net/jishulaozhuanjia/article/details/104801290"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=a.exports}}]);